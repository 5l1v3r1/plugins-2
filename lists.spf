\ Файл:         lists.spf
\ Автор:        VoidVolker
\ Дата:         15/08/2012 21:40
\ Описание:     Расширяемые односвязные списки с глобальным или локальным для потока выделением памяти.
\   Каждый список определяется заголовком, который содержит служебные параметры, являющиеся необходимой частью интерфейса для работы со списками. Слово "расширяемые" означает, что можно использовать в качестве значения списка адрес пользовательской структуры и записать в заголовок списка методы работы с этой структурой. При этом стандартные методы станут использовать эти самые пользовательские методы.
\ * Включает в состав библиотеку быстрой сортировки из дистрибутива спф ~pinka\samples\2003\common\QSORT.F
\ * Требуется подключенный плагин strings.spf или autostrings.spf для создания быстрых методов списка

  \ Список состоит из "заголовка" и "узлов":
  \  - в заголовке хранятся первый и последний узлы списка;
  \  - в узле в первой ячейке хранится адрес на следующий узел и пользовательское значение во второй ячейке.
\ --------------------------------------------------------------------------
\ Условные обозначения:
\     list - список, фактически адрес его заголовка
\     node - узел списка, адрес
\     value - значение узла списка, число; или строка в случае строкового списка
\     i - индекс, число
\     xt - выполнимый токен слова, адрес, предназначенный для передачи слову EXECUTE
\     -> - стековый коментарий относится к входному потоку
\     " name" - имя, отделенное разделителями
\     | - "или", указывает, что на стеке может быть одно из двух(нескольких) значений

\ Слова:
\ FOR-LIST   \ ( list xt -- ) \ Для каждого узла списка list выполнить xt
\ LIST-EXIT   \ ( -- ) \ Закончить просмотр списка.

\ LIST(   \ ( list -- ) \ Выполнить для каждого узла списка list код, ограниченный словом )LIST . Допускает вложенность. Только для режима компиляции.
\ )LIST   \ ( -- ) \ Закончить описание кода, начатого словом LIST( .  Только для режима компиляции.

\ NODE>@  \ ( node list -- value ) \ Получить значение узла node списка list
\ NODE>!   \ ( value node list --  ) \ Записать значение value в узел node списка list
\ VAL>=   \ ( value value list -- ? ) \ Сравнить два значения списка list
\ VAL-DROP>   \ ( value list -- ) \ Удалить значение списка list
\ VAL-DUP>   \ ( value list -- value value) \ Дублировать значение списка list
\ NODE>#   \ ( node list -- i|-1 ) \ Вычислить индекс узла node списка list. Вернуть -1 в случае отсутствия узла в списке.

\ NODE   \ ( -- node ) \ Получить адрес текущего узла списка. Только внутри цикла LIST( )LIST
\ NODE@  \ ( -- NodeValue ) \ Получить значение текущего узла списка. Только внутри цикла LIST( )LIST
\ NODE!  \ ( NodeValue --  ) \ Записать значение со стека в текущий узел списка. Только внутри цикла LIST( )LIST
\ VAL=   \ ( value1 value2 -- ? ) \ Сравнить два значения. Только внутри цикла LIST( )LIST
\ VAL-DROP   \ ( value -- ) \ Удалить значение со стека. Только внутри цикла LIST( )LIST
\ VAL-DUP   \ ( value -- value ) \ Дублировать значение на стеке. Только внутри цикла LIST( )LIST

\ LIST>   \ ( list -- ) \ Пошаговый цикл. Перейти к следующему узлу списка. Работает замкнуто - после последнего элемента будет ноль, затем снова первый узел. Слово предназначено для применения внутри пользовательских циклов, но прекрасно работает и в цикле LIST( )LIST
\ LIST@   \ ( list -- nodevalue|0 ) \ Получить текущее значение пошагового цикла списка. При переходе через конец списка результатом будет ноль и только потом первый узел
\ LIST@>   \ ( list -- nodevalue ) \  Получить текущее значение пошагового цикла и перейти к следующему узлу списка. Синоним фразы list LIST@ list LIST@>
\ LIST--   \ ( list -- ) \ Инициализировать пошаговый цикл списка list первым узлом.

\ NDEL   \ ( -- )  \ Удалить текущий узел списка. Только внутри цикла LIST( )LIST
\ LIST-FREE   \ ( list -- ) \ Полностью очистить список.
\ NODE-DEL   \ ( value list --) Удалить первый узел, который содержит указанное значение
\ LIST?   \ ( value list -- node|0) Проверить, хранится ли указанное значение в списке. Возвращает адрес узла, в котором хранится значение или 0, если значение не обнаружено.

\ !LIST   \ ( value list -- ) \ Добавить в начало списка значение value
\ LIST!   \ ( value list -- ) \ Добавить в конец списка значение value
\ LIST#!   \ ( val_1 ... val_n n list -- ) \ Добавить поочередно n значений со стека в конец списка list. Значения добавляются начиная с вершины стека в конец списка в порядке очереди.
\ #!LIST   \ ( val_1 ... val_n n list -- ) \ Добавить поочередно n значений со стека в начало списка list. Значения добавляются начиная с вершины стека в начало списка в порядке очереди.

\ LIST[   \ ( list -- list-handle list-pos ) \ Начать добавление значений в список.
\ ]LIST   \ ( list-handle list-pos x*i -- ) \ Закончить добавление значений в список. Слово вычисляет число значений, оказавшихся на стеке после слова LIST[ и добавляет их все в начало списка по порядку.

\ LIST#   \ ( list -- i ) \ Посчитать число узлов в списке list
\ LIST#>   \ ( i list -- node ) \ Получить узел node списка list под номером i
\ LIST#@   \ ( i list -- value ) \ Получить значение узла списка list

\ LIST-SORT   \ ( list -- ) \ Сортировка списка list от меньшего к большему по методу быстрой сортировки
\ LIST-RSORT   \ ( lis -- ) \ Сортировка списка list от большего к меньшему по методу быстрой сортировки

\ Статические списки
\ LIST:   \ ( " name" -> ) \ Создать список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше (*).
\ GLOBAL-LIST:   \ ( " name" -> ) \ Создать глобальный список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.

\ DLIST:   \ ( " name" -> ) \ Создать список для чисел двойной длины, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше.
\ GLOBAL-DLIST:   \ ( " name" -> ) \ Создать глобальный список для чисел двойной длины, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.

\ STRING-LIST:   \ ( " name" -> ) \ Создать строковый список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше(*).
\ GLOBAL-STRING-LIST:   \ ( " name" -> ) \ Создать глобальный строковый список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
\ (*) Это связано с тем, что перечитыванием кронтабов занимается отдельный поток. Соответственно до раздела Action: - один поток, а после, при выполнении задачи, - это уже будет другой поток. У глобальных списков таких ограничений нет.

\ При создании именованного статического списка автоматически создаются следующие слова для быстрой работы со списком:
\ : listname(   POSTPONE listname [COMPILE] LIST( ; IMMEDIATE
\ : )listname   [COMPILE] )LIST ; IMMEDIATE
\ : listname>   listname LIST> ;
\ : listname@   listname LIST@ ;
\ : listname@>   listname LIST@> ;
\ : listname--   listname LIST-- ;
\ : listname?   listname LIST? ;
\ : !listname   listname !LIST ;
\ : listname!   listname LIST! ;
\ : listname#!   listname LIST#! ;
\ : #!listname   listname #!LIST ;
\ : listname[   listname LIST[ ;
\ : ]listname   ]LIST ;
\ : listname#   listname LIST# ;
\ : listname#>   listname LIST#> ;
\ : listname#@  listname LIST#@ ;

\ Динамические списки
\ LIST   \ ( -- list ) \ Создать список. Для заголовка списка выделяется память из хипа: такой список можно уничтожить.
\ GLOBAL-LIST   \ ( -- list ) \ Создать глобальный список. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.

\ DLIST   \ ( -- list ) \ Создать список для чисел двойной длины. Для заголовка списка выделяется память из хипа: такой список можно уничтожить.
\ GLOBAL-DLIST   \ ( -- list ) \ Создать глобальный список для чисел двойной длины. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.

\ STRING-LIST   \ ( -- list ) \ Создать строковый список. Для заголовка списка выделяется память из хипа: такой список можно уничтожить. Работает исколючительно со строками. Динамически выделяет и освобождает для строк память.
\ GLOBAL-STRING-LIST   \ ( -- list ) \ Создать глобальный строковый список. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Работает исколючительно со строками. Динамически выделяет и освобождает для строк память. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.

\ LIST-DEL   \ ( list -- ) \ Уничтожить список и все его содержимое. Только для динамических списков.

\ LIST-MEDIAN   \ ( list -- median ) \ Вычислить медиану списка list. Медина - число, которое разделяет упорядоченный список чисел ровно в середине. Либо среднее арифметическое двух чисел в середине для списка из четного числа элементов.

\ --------------------------------------------------------------------------
\ Примеры использования списков

\ Создаем список:
\ LIST: list

\ Добавляем в него группу значений:
\ list[ 1 2 3 4 5 ]list

\ Вот так можно распечатать:
\ : list.   list( NODE@ . )list CR ;
\ Или вот так:
\ : list.1   list LIST( NODE@ . )LIST CR ;
\ Результат в обоих случаях будет одинаковый:
\ 1 2 3 4 5
\  Ok

\ А вот немного другой вариант:
\ : list#.   0 DO list@ list> . LOOP CR ;
\ И еще один вариант:
\ : list.2   list( NODE@ . NODE@ 3 = IF LIST-EXIT THEN )list CR ;

\ Результат:
\ 3 mylist#.
\ 1 2 3
\  Ok

\ Аналогично и со строковыми списками(*):
\ STRING-LIST: s
\ s[ " Строка" " Текст" " Имя" ]s
\ : s. s( NODE@ TYPE CR )s ;
\ Результат:
\ s.
\ Строка
\ Текст
\ Имя
\  Ok

\ (*) При использовании этого метода заполнения списка строками, в режиме интерпретации следует
\ распологать все строки в одной строке, т.к. при переходе интерпретатора к следующей строке
\ предыдущие строки будут стерты. Это особенность работы интерпретатора - он обрабатывает файл построчно.
\ А вот в режиме компиляции такой проблемы нет, т.к. строка сразу сохраняется в память системы.
\ Если строк много, то следует хранить их в файле и загружать в список построчным чтением файла. Например в цикле READ-BY-LINE

\ А вот так можно работать с деревьями и динамическими списками:
\ LIST: Tree
\ Tree[
  \ STRING-LIST DUP LIST[ " Ветвь дерева 1" "  Лист 1 ветви 1" "  Лист 2 ветви 1" ]LIST
  \ STRING-LIST DUP LIST[ " Ветвь дерева 2" "  Лист 1 ветви 2" "  Лист 2 ветви 2" ]LIST
\ ]Tree
\ : Tree. Tree( NODE@ LIST( NODE@ TYPE CR )LIST CR )Tree CR ;
\ : TreeFree  Tree( NODE@ LIST-DEL )Tree Tree LIST-FREE ;

\ Tree.
\ Ветвь дерева 1
 \ Лист 1 ветви 1
 \ Лист 2 ветви 1

\ Ветвь дерева 2
 \ Лист 1 ветви 2
 \ Лист 2 ветви 2
 \ Ok

\ После работы с деревом освободим его:
\ TreeFree

\ --------------------------------------------------------------------------

  \ value - пользовательское значение, может занимать различное число ячеек для разных списков
  \ list - список, фактически адрес заголовка списка
  \ node - узел списка
  \ nodevalue - значение, хранящееся в узле списка
  \ параметр:значение - обозначает какой-то параметр с новым значением, например адрес в памяти и его содержимое node:last-node или стек возвратов и его содержимое R: list node

\ --------------------------------------------------------------------------

MODULE: LIST_MODULE

  \ *** Код для спф
  \ REQUIRE {       lib/ext/locals.f \ }
  \ : ON -1 SWAP ! ;
  \ : OFF 0! ;
  \ : [NONAME
      \ ?COMP HERE BRANCH, >MARK 1
      \ HERE
  \ ; IMMEDIATE
  \ : NONAME]
      \ ?COMP RET,
      \ >R >RESOLVE
      \ R> POSTPONE LITERAL
  \ ; IMMEDIATE
  \ WINAPI: GlobalAlloc KERNEL32.DLL
  \ WINAPI: GlobalFree KERNEL32.DLL
  \ : GLOBAL-ALLOCATE ( bytes -- address ior)
      \ 0x40 GlobalAlloc DUP IF 0 ELSE GetLastError THEN ;
  \ : GLOBAL-FREE ( address - ior) GlobalFree ;

  \ *** Временный буфер
  \ Динамически выделяемый буфер для хранения служебных параметров в циклическом итераторе LIST( )LIST
  USER-VALUE ListSets
  0
  CELL -- -LSNode           \ Текущий узел списка
  CELL -- -LSPNode          \ Предыдущий узел списка
  CELL -- -LSList           \ Заголовок спика
  CELL -- -LSDo?            \ Флаг, разрешающий работу итератора
  CONSTANT /ListSets

  \ *** Заголовок списка
  0
  CELL -- -ListFirstNode    \ Первый узел списка
  CELL -- -ListLastNode     \ Последний узел списка
  CELL -- -ListNode         \ Текущий узел списка, необходимо для пошагового итератора
  CELL -- -ListValCells     \ Число ячеек для одного значения, используется в LIST[ ... ]LIST и при выделении памяти для ячеек
  \ А вот это пускай будут методы списка
  \ * Память
  CELL -- -ListAllocate     \ Выделение памяти для списка ( size -- addr ior )
  CELL -- -ListFree         \ Освобождение памяти, занятой списком ( addr -- ior )
  CELL -- -ListNodeFree     \ Освобождение памяти, занятой узлом списка ( node -- ior )
  \ После стекового комментария указано слово, выполняемое по-умоланию.
  \ Зачем именно так? А затем, что теперь мы можем просто записать нужные токены в заголовок списка и он будет работать с другими типами данных без изменения синтаксиса. Например работать с двойными(тройным) ячейками.
  \ * Элементы списка
  CELL -- -ListNode@        \ Получение значения ( node -- value ) val@
  CELL -- -ListNode!        \ Запись значения ( value node list* -- ) val!  (*) Заголвок списка нужен для доступа к методам памяти списка для строковых списков или других видов списка
  \ * Значение элемента
  CELL -- -ListVal=         \ Сравнение значения ( value1 value2 -- ? ) =
  CELL -- -ListValDrop      \ Удаление значения ( value -- ) DROP
  CELL -- -ListValDup       \ Дублирование значения ( value -- value value ) DUP
  CELL -- -ListVal<         \ Меньше? ( value1 value2 -- ? )
  CELL -- -ListVal>         \ Больше? ( value1 value2 -- ? )
  CELL -- -ListVal+         \ Сложение ( value1 value2 -- value3 )
  CELL -- -ListVal2/        \ Разделить на два ( value1 -- value2 )
  CONSTANT /ListHeader

  \ *** Извлечение и запись значения в узлы списка
  : val@   \ ( node -- value )
    CELL+ @ ;
  : val!   \ ( value node list* -- )
    DROP CELL+ !
  ;

  \ *** Заголовки списков с готовыми параметрами
  CREATE GlobalListHeader   0 , 0 , 0 , 1 ,
    ' GLOBAL-ALLOCATE ,
    ' GLOBAL-FREE ,
    ' GLOBAL-FREE ,
    ' val@ ,
    ' val! ,
    ' = ,
    ' DROP ,
    ' DUP ,
    ' < ,
    ' > ,
    ' + ,
    ' 2/ ,

  CREATE ListHeader   0 , 0 , 0 , 1 ,
    ' ALLOCATE ,
    ' FREE ,
    ' FREE ,
    ' val@ ,
    ' val! ,
    ' = ,
    ' DROP ,
    ' DUP ,
    ' < ,
    ' > ,
    ' + ,
    ' 2/ ,

  \ *** Слова для быстрого доступа к параметрам списка.
  : PNode   ListSets -LSPNode ;
  : PNode!   ListSets -LSPNode ! ;
  : PNode@   ListSets -LSPNode @ ;
  : List   ListSets -LSList ;
  : List!   ListSets -LSList ! ;
  : List@   ListSets -LSList @ ;
  : Do?   ListSets -LSDo? @ ;
  : DoOn   ListSets -LSDo? ON ;
  : DoOff   ListSets -LSDo? OFF ;

EXPORT

  \ *** Циклический итератор FOR-LIST
  : FOR-LIST { xt -- } \ ( list xt -- ) \ Для каждого узла списка list выполнить xt
    \ Динамическое выделение буфера для параметров списка позволяет использовать вложенность
    \ Все параметры списка хранятся во временном буфере
    ListSets >R                             \ Сохраняем предыдущий буфер
    /ListSets ALLOCATE THROW TO ListSets    \ Выделяем новый буфер
    DUP List!                               \ Сохраняем идентификатор списка
    DoOn                                    \ Разрешаем итерацию
    DUP PNode!                              \ Предыдущим узлом устанавливаем заголовок списка
    @ ListSets !                            \ Сохраняем первый узел списка во временный буфер
    BEGIN ListSets @ Do? AND WHILE          \ Запускаем цикл по всем узлам
      xt EXECUTE                            \ Выполняем токен
      ListSets @ DUP PNode!                 \ Сохраняем текущий узел как предыдущий
      @ ListSets !                          \ Получаем следующий узел
    REPEAT
    ListSets FREE THROW                     \ Освобождаем текущий буфер
    R> TO ListSets                          \ Восстанавливаем предыдущий буфер
  ;

  : LIST-EXIT   \ ( -- ) \ Закончить просмотр списка.
    ListSets -LSDo? OFF  \ Синоним DoOff
  ;

  \ *** Непрерывный цикл LIST( )LIST
  : LIST(   \ ( list -- ) \ Выполнить для каждого узла списка list код, ограниченный словом )LIST . Допускает вложенность. Только для режима компиляции.
    POSTPONE [NONAME
  ; IMMEDIATE

  : )LIST   \ ( -- ) \ Закончить описание кода, начатого словом LIST( .  Только для режима компиляции.
    POSTPONE NONAME]
    POSTPONE FOR-LIST
  ; IMMEDIATE

  \ *** Методы списка
  : NODE>@  \ ( node list -- value ) \ Получить значение узла node списка list
    -ListNode@ @ EXECUTE  ;
  : NODE>!   \ ( value node list --  ) \ Записать значение value в узел node списка list
    DUP -ListNode! @ EXECUTE  ;
  : VAL>=   \ ( value1 value2 list -- ? ) \ Сравнить два значения списка list
    -ListVal= @ EXECUTE  ;
  : VAL-DROP>   \ ( value list -- ) \ Удалить значение списка list
    -ListValDrop @ EXECUTE  ;
  : VAL-DUP>   \ ( value list -- value value) \ Дублировать значение списка list
    -ListValDup @ EXECUTE  ;
  : VAL><   \ ( value1 value2 list -- ? ) \ Сравнить два значения списка list
    -ListVal< @ EXECUTE  ;
  : VAL>>   \ ( value1 value2 list -- ? ) \ Сравнить два значения списка list
    -ListVal> @ EXECUTE
  ;
  : VAL>+   \ ( value1 value2 list -- value3 ) \ Сложить два значения списка list
    -ListVal+ @ EXECUTE
  ;


  \ *** Быстрые методы LIST( )LIST
  : NODE   \ ( -- Node ) \ Получить адрес текущего узла списка. Только внутри цикла LIST( )LIST
    ListSets @
  ;

  : NODE@  \ ( -- NodeValue ) \ Получить значение текущего узла списка. Только внутри цикла LIST( )LIST
    ListSets @ List@ NODE>@  ;
  : NODE!  \ ( NodeValue --  ) \ Записать значение со стека в текущий узел списка. Только внутри цикла LIST( )LIST
    ListSets @ List@ NODE>!  ;
  : VAL=   \ ( value1 value2 -- ? ) \ Сравнить два значения. Только внутри цикла LIST( )LIST
    List@ VAL>=  ;
  : VAL-DROP   \ ( value -- ) \ Удалить значение со стека. Только внутри цикла LIST( )LIST
    List@ VAL-DROP>  ;
  : VAL-DUP   \ ( value -- value ) \ Дублировать значение на стеке. Только внутри цикла LIST( )LIST
    List@ VAL-DUP>
  ;

  : NODE>#   \ ( node list -- i|-1 ) \ Вычислить индекс узла node списка list. Вернуть -1 в случае отсутствия узла в списке
    0 ROT ROT 0 SWAP    \ 0 node 0 list
    LIST(
      OVER NODE =
      IF
        LIST-EXIT
        2>R DROP -1 2R>
      ELSE
        1+
      THEN
    )LIST NIP
    SWAP IF ELSE DROP -1 THEN
  ;

  \ *** Пошаговый цикл
  : LIST>   \ ( list -- ) \ Пошаговый цикл. Перейти к следующему узлу списка. Работает замкнуто - после последнего элемента будет ноль, затем снова первый узел. Слово предназначено для применения внутри пользовательских циклов, но прекрасно работает в цикле LIST( )LIST
  \ Это слово требует при создании списка установку текущего узла списка одновременно с первым элементом (решено в слове !LIST )
  \ Возможный конфликт при удалении узла в цикле LIST( )LIST предусмотрен в слове NDEL
    DUP -ListNode @
    IF  \ list                                  \ переходим к следующему узлу списка
      DUP -ListNode @ @ SWAP -ListNode !    \ Устанавливаем следующий узел списка текущим
    ELSE  \ list \ Список пуст; достигнут конец списка или цикл не инициализирован
      DUP ( -ListFirstNode ) @
      IF  \ list \ Список не пуст, цикл не инициализирован.
        DUP ( -ListFirstNode ) @ SWAP       \ Получаем первый узел списка
        -ListNode !                         \ И устанавливаем его текущим узлом
      ELSE  \ list \ Список пуст
        DROP                                \ Заголовок списка не нужен
      THEN
    THEN
  ;

  : LIST@   \ ( list -- nodevalue|0 ) \ Получить текущее значение пошагового цикла списка. При переходе через конец списка результатом будет ноль и только потом первый узел
  \ Именно такое решение обусловлено следующими моментами:
  \  - список может быть пустым - эта проверка нужна в любом случае;
  \  - упрощает слово LIST> ;
  \  - удобно использовать в цикле BEGIN WHILE REPEAT - ноль при достижении конца списка;
  \  - не нужно дополнительное слово для проверки достижения конца списка.
    DUP -ListNode @
    DUP IF
      SWAP NODE>@
    ELSE
      DROP -ListValCells @ 0 DO 0 LOOP
    THEN
  ;

  : LIST@>   \ ( list -- nodevalue ) \  Получить текущее значение пошагового цикла и перейти к следующему узлу списка. Синоним фразы list LIST@ list LIST@>
    DUP >R LIST@ R> LIST>
  ;

  : LIST--   \ ( list -- ) \ Инициализировать пошаговый цикл списка list первым узлом.
    DUP @ SWAP -ListNode !
  ;

  \ *** Удаление узлов списка
  : NDEL   \ ( -- )  \ Удалить текущий узел списка. Только внутри цикла LIST( )LIST
    ListSets @          \ node
    DUP @ SWAP          \ node+1 node   \ Получаем следующий узел списка и кладем его во вторую позицию в стеке
    List@ -ListNode @ OVER =          \ И на всякий случай проверяем, не на текущем ли узле остановился пошаговый итератор:
    IF  \ Да, удаляемый узел используется пошаговым итератором
      List@ LIST>                     \ Устанавливаем следующий узел как текущий для пошагового итератора
    THEN

    List@ -ListNodeFree @ EXECUTE THROW   \ node+1 \ Освобождаем текущий узел
        DUP IF ELSE PNode@ List@ CELL+ ! THEN     \ И если это последний в списке узел - то сохраняем его во вторую ячейку заголовка списка
    PNode@ !                                      \ Текущий узел записываем в предыдущий
    PNode@ ListSets !                             \ И устанавливаем предыдущий узел текущим узлом для цикла FOR-LIST. Т.о. для цикла BEGIN слова FOR-LIST получается так, как если бы этот узел списка и не обрабатывался - как если бы прокрутили цикл на один шаг без изменения переменных.
  ;

  \ *** Удаление списка
  : LIST-FREE   \ ( list -- ) \ Полностью очистить список.
    DUP -ListNode OFF       \ Обнуляем текущий узел из заголовка
    DUP LIST( NDEL )LIST    \ Удаляем все узлы списка
    DUP OFF                 \ Обнуляем первый узел из заголовка
    -ListLastNode OFF       \ обнуляем последний узел из заголовка
  ;

  \ *** Удаление значения из списка
  : NODE-DEL   \ ( value list --) Удалить первый узел, который содержит указанное значение
    DUP >R LIST( \ value
      VAL-DUP NODE@ VAL=
        IF
          NDEL
          LIST-EXIT
        THEN
    )LIST
    R> VAL-DROP>
  ;

  \ *** Поиск в списке
  : LIST?   \ ( value list -- node|0) Проверить, хранится ли указанное значение в списке. Возвращает адрес узла, в котором хранится значение или 0, если значение не обнаружено.
    DUP >R
    0 SWAP LIST(  \ value 0
      DROP
      VAL-DUP NODE@ VAL=
      IF
        LIST-EXIT NODE
      ELSE
        0
      THEN
    )LIST
    R> SWAP >R
    VAL-DROP>
    R>
  ;

  \ *** Добавление узлов в список
  : !LIST   \ ( value list -- ) \ Добавить в начало списка значение value
    \ * Выделение памяти                      \ value list

    \ [ 2 CELLS LIT, ] OVER                 \ value list size list
    DUP -ListValCells @ CELLS CELL+ OVER                 \ value list size list

    -ListAllocate @ EXECUTE THROW >R      \ value list            R: new-node
    \ * Пошаговый цикл                        \ value list            R: new-node
    DUP ( -ListFirstNode ) @
    OVER -ListNode @ OVER 0= >R = R> OR
    IF  \ Список пуст или пошаговый цикл был на первом узле списка?
      DUP -ListNode R@ SWAP !             \ Инициализируем пошаговый цикл создаваемым узлом
    THEN
    \ * Инициализация пустого списка          \ value list            R: new-node
    DUP ( -ListFirstNode ) @              \ Если первого узла в списке нет - значит список пустой
    IF ELSE R@ OVER -ListLastNode ! THEN  \ Устанавливаем создаваемый узел как последний узел
    \ * Установка связи между новым и первым узлами
    DUP @ R@ !                            \ value list            R: new-node:node
    \ * Устанавливаем создаваемый узел в качестве первого узла списка
    R@ OVER ( -ListFirstNode ) !          \ value list            R: new-node        \ list:new-node
    \ * Запись значения                       \ value list            R: new-node
    R> SWAP NODE>!
  ;

  : LIST!   \ ( value list -- ) \ Добавить в конец списка значение value
    DUP -ListLastNode @ ?DUP
    IF \ В списке уже есть узлы
      \ * Выделение памяти                    \ value list lastnode

      \ OVER [ 2 CELLS LIT, ] SWAP          \ value list lastnode size list   R: new-node
      OVER DUP -ListValCells @ CELLS CELL+ SWAP                 \ value list size list

      -ListAllocate @ EXECUTE THROW  >R   \ value list lastnode             R: new-node
      \ * Установка связи между последним и новым узлами
      R@ SWAP !                           \ value list                      R: new-node \ lastnode:new-node
      \ * Запись нового узла как последнего в заголовок списка
      R@ OVER -ListLastNode !             \ value list                      R: new-node   \ list+cell:new-node
      \ * Запись значения
      R> SWAP NODE>!
    ELSE \ value list \ Это будет первый узел списка
      !LIST
    THEN
  ;

  \ *** Добавление нескольких значений
  : LIST#!   \ ( val_1 ... val_n n list -- ) \ Добавить поочередно n значений со стека в конец списка list. Значения добавляются начиная с вершины стека в конец списка в порядке очереди.
    OVER IF
      SWAP 0 DO DUP >R LIST! R> LOOP DROP
    ELSE 2DROP THEN
  ;

  : #!LIST   \ ( val_1 ... val_n n list -- ) \ Добавить поочередно n значений со стека в начало списка list. Значения добавляются начиная с вершины стека в начало списка в порядке очереди.
    OVER IF
      SWAP 0 DO DUP >R !LIST R> LOOP DROP
    ELSE 2DROP THEN
  ;

DEFINITIONS

  USER-VALUE list-pos
  USER-VALUE list-handle

EXPORT

  : LIST[   \ ( list -- list-handle list-pos ) \ Начать добавление значений в список.
    list-handle SWAP              \ Сохраняем текущее значение list-handle на стеке
    TO list-handle                \ И запоминаем список в list-handle
    list-pos                      \ Аналогично делаем и с list-pos
    DEPTH TO list-pos
  ;

  : ]LIST   \ ( list-handle list-pos x*i -- ) \ Закончить добавление значений в список. Слово вычисляет число значений, оказавшихся на стеке после слова LIST[ и добавляет их все в начало списка по порядку.
    DEPTH list-pos -
    list-handle -ListValCells @ /   \ Делим число элементов на стеке на размер элемента списка
    list-handle #!LIST                \ Добавляем элементы в список
    TO list-pos                     \ Восстанавливаем list-pos и list-handle
    TO list-handle
  ;

  \ *** Подсчет числа узлов списка
  : LIST#   \ ( list -- i ) \ Посчитать число узлов в списке list
    0 SWAP LIST( 1+ )LIST
  ;

  \ *** Получение узла по индексу
  : LIST#>   \ ( i list -- node ) \ Получить узел node списка list под номером i
    0 SWAP LIST(
      2DUP =
      IF
        NODE LIST-EXIT
      ELSE
        1+
      THEN
    )LIST
    NIP NIP
  ;

  \ *** Получение значения по индексу
  : LIST#@   \ ( i list -- value ) \ Получить значение узла списка list
    SWAP OVER LIST#>
    SWAP NODE>@
  ;

DEFINITIONS

  \ *** Сортировка списков
  USER-VALUE ListForSort
  USER-VECT []>[]
  USER-VECT []<[]

  :NONAME   \ ( a b -- )
    \ Для простоты меняем местами значения узлов, а не сами узлы, считая, что все узлы одинаковой размерности
    \ ." e ("
    ListForSort LIST#> SWAP ListForSort LIST#>        \ node1 node2
    ListForSort -ListValCells @ 2 = IF
      CELL+ SWAP CELL+        \ addr1 addr2
      OVER >R DUP >R          \ addr1 addr2     \ R: addr1 addr2 --
      2@ ROT 2@                \ dval2 dval1     \ R: addr1 addr2 --
      R> 2! R> 2!
    ELSE
      CELL+ SWAP CELL+        \ addr1 addr2
      2DUP @ SWAP @           \ addr1 addr2 val2 val1
      ROT ! SWAP !
    THEN
    \ ." ) e" CR
  ; ->VECT []exch[]

  : (ivals>)   \ ( i j -- flag  )
    \ ." < ("
    >R ListForSort LIST#@
    R> ListForSort LIST#@
    ListForSort VAL>>
    \ ." ) >" CR
  ;

  : (ivals<)   \ ( i j -- flag  )
    \ ." < ("
    >R ListForSort LIST#@
    R> ListForSort LIST#@
    ListForSort VAL><
    \ ." ) >" CR
  ;

  \ Библиотека быстрой сортировки из дистрибутива спф ~pinka\samples\2003\common\QSORT.F
  \ ***** Начало файла
  \ ( It sample for sortings in forth /SPF3.75/.   comments - RUS, CP-1251 )
  \ 02.10.99г. 16:53:36
  \ 18.05.2000
  \ 24.05.2000
  \ 18.11.2000 ver. 1.0. Привел к виду документированного примера.
  \ Ruvim Pinka (ruvim@forth.org.ru)

  \ ==================================================================
  \ ( QuickSort - Быстрая сортировка. Универсальная реализация /-ключи любые/.
    \ Требует наличие слов
      \ []exch[] [ a b -- ]     \ обменять ключи элементов i и j
      \ []>[]  [ i j -- flag ]  \ flag=true, если  i_key > j_key
      \ []<[]  [ i j -- flag ]  \ flag=true, если  i_key < j_key
  \ Порядок сортировки задается словами сравнения ( []>[] и []<[] )


  : sort23 { il ir -- }  \  сортировка двух или трех элементов
    il ir  = IF EXIT THEN
    il ir  []>[] IF il ir []exch[] THEN
    il 1+ DUP ir <> IF ( i )
        DUP il []<[] IF DUP il []exch[] ELSE
        DUP ir []>[] IF DUP ir []exch[] THEN
    THEN THEN DROP
  ;

  \ Рекурсивная
  : quick_sort ( left right -- )  \ left <= rigth
    { il ir \ mid }
      ir il -  3 < IF   il ir  sort23
      ELSE
        il ir 2DUP + 2/  -> mid \ запоминание номера среднего ключа
        BEGIN  ( left right )
          BEGIN  il mid []<[] WHILE il 1+ -> il REPEAT
          BEGIN  mid ir []<[] WHILE ir 1- -> ir REPEAT
          il ir >  0=  IF \ левый не больше правого
             il mid = IF ir -> mid ELSE
             ir mid = IF il -> mid THEN
             THEN
             il ir []exch[]  il 1+ -> il ir 1- -> ir
          THEN
          il ir >
        UNTIL  ( left right )
        il SWAP   RECURSE
        ir        RECURSE
      THEN
  ;
  \ ***** Конец файла

EXPORT

  : LIST-SORT   \ ( list -- )
    DUP @ IF
      ListForSort >R
      ['] (ivals>) TO []>[]
      ['] (ivals<) TO []<[]
      DUP TO ListForSort
      0 SWAP LIST# 1-
      quick_sort
      R> TO ListForSort
    ELSE
      DROP
    THEN
  ;

  : LIST-RSORT   \ ( list -- )
    DUP @ IF
      ListForSort >R
      ['] (ivals<) TO []>[]
      ['] (ivals>) TO []<[]
      DUP TO ListForSort
      0 SWAP LIST# 1-
      quick_sort
      R> TO ListForSort
    ELSE
      DROP
    THEN
  ;


  \ *** Создание именованного списка и генерация всех методов списка
  CREATE NameBufAddr 128 ALLOT
  QUAN NameBuf#
  : NameBuf NameBufAddr NameBuf# ;

  : (LIST)   \ ( a_name u_name init_header -- )
    HERE >R /ListHeader ALLOT       \ Выделяем память для заголовка
    R@ /ListHeader CMOVE>
    \ ." LIST (" CR
    TO NameBuf#
    NameBufAddr NameBuf# CMOVE

    " VALUE %NameBuf%" R> ROT ROT EVALUATE
    " : %NameBuf%(   POSTPONE %NameBuf% [COMPILE] LIST( ; IMMEDIATE " EVALUATE
    " : )%NameBuf%   [COMPILE] )LIST ; IMMEDIATE " EVALUATE
    " : %NameBuf%>   %NameBuf% LIST> ; " EVALUATE
    " : %NameBuf%@   %NameBuf% LIST@ ; " EVALUATE
    " : %NameBuf%@>   %NameBuf% LIST@> ; " EVALUATE
    " : %NameBuf%--   %NameBuf% LIST-- ; " EVALUATE
    " : %NameBuf%?   %NameBuf% LIST? ; " EVALUATE
    " : !%NameBuf%   %NameBuf% !LIST ; " EVALUATE
    " : %NameBuf%!   %NameBuf% LIST! ; " EVALUATE
    " : %NameBuf%#!   %NameBuf% LIST#! ; " EVALUATE
    " : #!%NameBuf%   %NameBuf% #!LIST ; " EVALUATE
    " : %NameBuf%[   %NameBuf% LIST[ ; " EVALUATE
    " : ]%NameBuf%   ]LIST ; " EVALUATE
    " : %NameBuf%#   %NameBuf% LIST# ; " EVALUATE
    " : %NameBuf%#>   %NameBuf% LIST#> ; " EVALUATE
    " : %NameBuf%#@  %NameBuf% LIST#@ ; " EVALUATE
    \ ." ) LIST" CR
  ;


  \ *** Именованные статические списки
  : LIST:   \ ( " name" -> ) \ Создать список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше.
    BL PARSE ListHeader (LIST)
  ;

  : GLOBAL-LIST:   \ ( " name" -> ) \ Создать глобальный список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    BL PARSE GlobalListHeader (LIST)
  ;

DEFINITIONS

  \ *** Расширения списков
  \ * Запись строки
  : NodeS!   \ ( a u node list -- )
    OVER CELL+ 2@ DROP DUP                    \ Освобождаем старую строку, если она есть
    IF
      OVER -ListFree @ EXECUTE THROW
    ELSE DROP THEN

    -ListAllocate @ SWAP >R >R      \ a u node list   \ Выделяем память для новой строки и записываем её в узел списка
    DUP 1+                          \ a u u+cel+1     R: node xt --
    R> EXECUTE THROW >R             \ a u             R: node a0 --
    SWAP OVER                       \ u a u           R: node a0 --
    R@ SWAP CMOVE                   \ u               R: node a0 --
    R> SWAP R> CELL+ 2!

    \ DUP [ CELL 1+ LIT, ] +          \ a u u+cell+1
    \ R> EXECUTE THROW >R             \ a u            R: a0
    \ DUP R@ !                        \ a u            R: a0
    \ R@ CELL+ SWAP                   \ a a1 u
    \ CMOVE
    \ R> R> CELL+ !
  ;

  \ * Извлечение строки
  : NodeS@   \ ( node -- a u )
    CELL+ 2@
    \ CELL+ @ DUP @ SWAP CELL+ SWAP
  ;

  \ * Сравнение строк
  : s=   \ ( a1 u1 a2 u2 -- ? )
    COMPARE 0=
  ;

  : NodeFree   \ ( node -- ior )
    DUP CELL+ 2@ DROP FREE THROW
    FREE
  ;

  : GlobalNodeFree   \ ( node -- ior )
    DUP CELL+ 2@ DROP GLOBAL-FREE THROW
    GLOBAL-FREE
  ;

  : s<   \ ( a1 u1 a2 u2 -- ? )
    { a1 u1 a2 u2 -- }
    u1 IF ELSE TRUE EXIT THEN
    u2 IF ELSE FALSE EXIT THEN
    0 u1 u2 MIN 0 DO
      a1 I + C@
      a2 I + C@
      2DUP <> IF
        < OR LEAVE
      ELSE
        2DROP
      THEN
    LOOP
  ;

  : s>   \ ( a1 u1 a2 u2 -- ? )
    { a1 u1 a2 u2 -- }
    u1 IF ELSE FALSE EXIT THEN
    u2 IF ELSE TRUE EXIT THEN
    0 u1 u2 MIN 0 DO
      a1 I + C@
      a2 I + C@
      2DUP <> IF
        > OR LEAVE
      ELSE
        2DROP
      THEN
    LOOP
  ;

  CREATE GlobalStringListHeader   0 , 0 , 0 , 2 ,
    ' GLOBAL-ALLOCATE ,
    ' GLOBAL-FREE ,
    ' GlobalNodeFree ,
    ' NodeS@ ,
    ' NodeS! ,
    ' s= ,
    ' 2DROP ,
    ' 2DUP ,
    ' s< ,
    ' s> ,
    ' S+ ,
    ' NOOP ,

  CREATE StringListHeader   0 , 0 , 0 , 2 ,
    ' ALLOCATE ,
    ' FREE ,
    ' NodeFree ,
    ' NodeS@ ,
    ' NodeS! ,
    ' s= ,
    ' 2DROP ,
    ' 2DUP ,
    ' s< ,
    ' s> ,
    ' S+ ,
    ' NOOP ,

EXPORT

  : STRING-LIST:   \ ( " name" -> ) \ Создать строковый список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить.  Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше.
    BL PARSE StringListHeader (LIST)
  ;

  : GLOBAL-STRING-LIST:   \ ( " name" -> ) \ Создать глобальный строковый список, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    BL PARSE GlobalStringListHeader (LIST)
  ;

  \ * Числа двойной длины
  : D> 2SWAP D< ;   \ Вот тоже интересный момент: D< есть в кроне, а D> - нет.

DEFINITIONS
  : dval@   \ ( node -- value )
    CELL+ 2@ ;
  : dval!   \ ( value node list* -- )
    DROP CELL+ 2!
  ;
  \ *** Заголовки списков с готовыми параметрами
  CREATE GlobalDListHeader   0 , 0 , 0 , 2 ,
    ' GLOBAL-ALLOCATE ,
    ' GLOBAL-FREE ,
    ' GLOBAL-FREE ,
    ' dval@ ,
    ' dval! ,
    ' D= ,
    ' 2DROP ,
    ' 2DUP ,
    ' D< ,
    ' D> ,
    ' D+ ,
    ' D2/ ,

  CREATE DListHeader   0 , 0 , 0 , 2 ,
    ' ALLOCATE ,
    ' FREE ,
    ' FREE ,
    ' dval@ ,
    ' dval! ,
    ' D= ,
    ' 2DROP ,
    ' 2DUP ,
    ' D< ,
    ' D> ,
    ' D+ ,
    ' D2/ ,

EXPORT

  : DLIST:   \ ( " name" -> ) \ Создать список для чисел двойной длины, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Слово является VALUE-переменной. В задачах добавлять и читать значения из списка следует в разделе Action:, не раньше.
    BL PARSE DListHeader (LIST)
  ;

  : GLOBAL-DLIST:   \ ( " name" -> ) \ Создать глобальный список для чисел двойной длины, имя списка берется из входного потока. Для заголовка списка выделяется память из кодофайла: список можно освободить, но нельзя уничтожить. Список доступен для всех потоков. Слово является VALUE-переменной. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    BL PARSE GlobalDListHeader (LIST)
  ;

  \ *** Автоматическое создание и уничтожение списков
  : LIST   \ ( -- list ) \ Создать список. Для заголовка списка выделяется память из хипа: такой список можно уничтожить.
    /ListHeader ALLOCATE THROW
    ListHeader OVER /ListHeader CMOVE
  ;

  : GLOBAL-LIST   \ ( -- list ) \ Создать глобальный список. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    /ListHeader GLOBAL-ALLOCATE THROW
    GlobalListHeader OVER /ListHeader CMOVE
  ;

  : STRING-LIST   \ ( -- list ) \ Создать строковый список. Для заголовка списка выделяется память из хипа: такой список можно уничтожить. Работает исколючительно со строками. Динамически выделяет и освобождает для строк память.
    /ListHeader ALLOCATE THROW
    StringListHeader OVER /ListHeader CMOVE
  ;

  : GLOBAL-STRING-LIST   \ ( -- list ) \ Создать глобальный строковый список. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Работает исколючительно со строками. Динамически выделяет и освобождает для строк память. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    /ListHeader GLOBAL-ALLOCATE THROW
    GlobalStringListHeader OVER /ListHeader CMOVE
  ;

  : DLIST   \ ( -- list ) \ Создать список для чисел двойной длины. Для заголовка списка выделяется память из хипа: такой список можно уничтожить.
    /ListHeader ALLOCATE THROW
    DListHeader OVER /ListHeader CMOVE
  ;

  : GLOBAL-DLIST   \ ( -- list ) \ Создать глобальный список для чисел двойной длины. Для заголовка списка выделяется память из глобального хипа: такой список можно уничтожить. Список доступен для всех потоков. Добавлять и читать значения из глобального списка можно сразу же после его создания и из любого потока и любой задачи.
    /ListHeader GLOBAL-ALLOCATE THROW
    GlobalDListHeader OVER /ListHeader CMOVE
  ;

  : LIST-DEL   \ ( list -- ) \ Уничтожить список и все его содержимое.
    DUP LIST-FREE
    DUP -ListFree @ EXECUTE THROW
  ;

  \ ***** Дополнительные слова *****
  \ *** Статистика
  \ * Вычисление медианы.
  : LIST-MEDIAN   \ ( list -- median ) \ Вычислить медиану списка list. Медина - число, которое разделяет упорядоченный список чисел ровно в середине. Либо среднее арифметическое двух чисел в середине для списка из четного числа элементов.
    DUP @ IF
      DUP LIST-SORT
      DUP LIST# DUP 2/
      SWAP 2 MOD IF \ Число элементов четное
        \ list count/2
        SWAP LIST#@
      ELSE \ Число элементов нечетное
        OVER >R 2DUP 2>R
        1- SWAP     \ list count/2 count/2+1 list
        LIST#@
        2R> SWAP LIST#@
        R@ VAL>+ R> -ListVal2/ @ EXECUTE
      THEN
    ELSE   \ Список пуст
      DROP 0
    THEN
  ;

;MODULE
